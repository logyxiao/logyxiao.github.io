<!DOCTYPE html><html lang="zh-cn" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="sitemap" href="/sitemap-index.xml"><!-- 防止样式闪烁的优化 --><style>
	/* 防止FOUC的最小CSS */
	html { visibility: hidden; opacity: 0; }
	html.loaded { visibility: visible; opacity: 1; transition: opacity 0.3s ease; }
	/* 基础字体和背景 */
	body { 
		font-family: 'Roboto', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, sans-serif;
		background-color: #ffffff;
		color: #171717;
		line-height: 1.6;
	}
</style><!-- CSS预加载 --><link rel="preload" href="/_astro/global.css" as="style"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- RSS Feed --><link rel="alternate" type="application/rss+xml" title="Logyxiao's Blog" href="https://logyxiao.cc/rss.xml"><meta name="generator" content="Astro v5.13.5"><!-- Canonical URL --><link rel="canonical" href="https://logyxiao.cc/blog/frontend/vue/0/"><!-- Primary Meta Tags --><title>Vue双向绑定实现</title><meta name="title" content="Vue双向绑定实现"><meta name="description" content><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://logyxiao.cc/blog/frontend/vue/0/"><meta property="og:title" content="Vue双向绑定实现"><meta property="og:description" content><meta property="og:image" content="https://logyxiao.cc/_astro/loading.MEf-iKv8.gif"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://logyxiao.cc/blog/frontend/vue/0/"><meta property="twitter:title" content="Vue双向绑定实现"><meta property="twitter:description" content><meta property="twitter:image" content="https://logyxiao.cc/_astro/loading.MEf-iKv8.gif"><!-- 防止FOUC的脚本 --><script>
	// 页面加载完成后显示内容
	document.addEventListener('DOMContentLoaded', () => {
		document.documentElement.classList.add('loaded');
	});
	
	// 如果DOMContentLoaded已经触发（例如缓存页面）
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			document.documentElement.classList.add('loaded');
		});
	} else {
		document.documentElement.classList.add('loaded');
	}
</script><link rel="stylesheet" href="/_astro/WalineComment.BwbXQ6L5.css">
<link rel="stylesheet" href="/_astro/about.DlL42Nbk.css">
<link rel="stylesheet" href="/_astro/about.BOdszQ9h.css"></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>Logyxiao&#39;s Blog</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/zh-cn/" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 首页 </a>  <a href="/zh-cn/blog" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 博客 </a>  <a href="/zh-cn/movies" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 影视 </a>  <a href="/zh-cn/about" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> 关于 </a>  <div class="language-dropdown" data-astro-cid-d2mhfzrs> <button class="dropdown-trigger" id="language-trigger" data-astro-cid-d2mhfzrs> <span data-astro-cid-d2mhfzrs>语言</span> <svg class="dropdown-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-d2mhfzrs> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" data-astro-cid-d2mhfzrs></path> </svg> </button> <div class="dropdown-menu" id="language-menu" data-astro-cid-d2mhfzrs> <a href="/zh-cn/blog/frontend/vue/0/" class="dropdown-item active" data-lang="zh-cn" data-astro-cid-d2mhfzrs> <span class="lang-name" data-astro-cid-d2mhfzrs>简体中文</span> <svg class="check-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-d2mhfzrs> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" data-astro-cid-d2mhfzrs></path> </svg> </a><a href="/en/blog/frontend/vue/0/" class="dropdown-item " data-lang="en" data-astro-cid-d2mhfzrs> <span class="lang-name" data-astro-cid-d2mhfzrs>English</span>  </a> </div> </div>  <script type="module">document.addEventListener("DOMContentLoaded",()=>{const o=document.getElementById("language-trigger"),t=document.getElementById("language-menu"),r=document.querySelector(".language-dropdown");if(!o||!t||!r)return;const s=()=>{t.classList.toggle("show");const e=o.querySelector(".dropdown-arrow");e&&(e.style.transform=t.classList.contains("show")?"rotate(180deg)":"")};o.addEventListener("click",e=>{e.preventDefault(),e.stopPropagation(),s()}),document.addEventListener("click",e=>{if(!r.contains(e.target)){t.classList.remove("show");const n=o.querySelector(".dropdown-arrow");n&&(n.style.transform="")}}),t.querySelectorAll(".dropdown-item").forEach(e=>{e.addEventListener("click",n=>{const a=e.getAttribute("href");a&&(window.location.href=a)})})});</script> </div> </nav> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="hero-image" data-astro-cid-bvzihdzo>  </div> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <h1 data-astro-cid-bvzihdzo>Vue双向绑定实现</h1> <div class="date" data-astro-cid-bvzihdzo> 2020年3月25日 </div> </div> </div> <div class="blog-content-toc-wrapper" data-astro-cid-bvzihdzo> <div class="blog-content-main prose blog-content-centered" data-astro-cid-bvzihdzo>  <ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFmvvm">什么是mvvm</a></li>
<li><a href="#Vue%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">Vue的优点是什么</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3">对于生命周期的理解</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC">组件传值</a></li>
<li><a href="#vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">vue数据绑定原理</a></li>
<li><a href="#vue-router%E5%8E%9F%E7%90%86">vue-router原理</a></li>
<li><a href="#vuex%E5%8E%9F%E7%90%86">vuex原理</a></li>
<li><a href="#v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB">v-if和v-show的区别</a></li>
<li><a href="#vue%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">vue怎么实现页面的权限控制</a></li>
<li><a href="#keep-alive%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">keep-alive有什么作用</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">计算属性有什么作用</a></li>
<li><a href="#route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB">$route和$router的区别</a></li>
<li><a href="#watch%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">watch的作用是什么</a></li>
<li><a href="#vue-loader%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E5%93%AA%E4%BA%9B">vue-loader是什么？使用它的用途有哪些？</a></li>
<li><a href="#%E5%81%87%E8%AE%BE%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84a123%E7%9B%B8%E5%BA%94%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%80%BC%E4%B8%BA123%E7%8E%B0%E8%AE%BEa05%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%80%BC%E4%BC%9A%E5%8F%98%E6%88%90523%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88">假设定义了一个数组a=[1,2,3]，相应的，页面上显示的值为1,2,3，现设a[0]=5，页面上的值会变成5,2,3吗？为什么？</a></li>
</ul>
<h2 id="什么是mvvm"><a class="heading-link" aria-label="链接到此标题" href="#什么是mvvm">什么是mvvm</a></h2>
<p>MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离
把Model和View关联起来的就是ViewModel。<br>
ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model<br>
View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由viewModel完成，在这里指VUE）<br>
因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理<br></p>
<h4 id="viewmodel如何编写"><a class="heading-link" aria-label="链接到此标题" href="#viewmodel如何编写">ViewModel如何编写？</a></h4>
<p>需要用JavaScript编写一个通用的ViewModel，这样，就可以复用整个MVVM模型了</p>
<p>一个MVVM框架和jQuery操作DOM相比有什么区别？
我们先看用jQuery实现的修改两个DOM节点的例子：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>&#x3C;!-- HTML --></span></span>
<span class="line"><span>&#x3C;p>Hello, &#x3C;span id="name">Bart&#x3C;/span>!&#x3C;/p></span></span>
<span class="line"><span>&#x3C;p>You are &#x3C;span id="age">12&#x3C;/span>.&#x3C;/p></span></span>
<span class="line"><span></span></span>
<span class="line"><span>Hello, Bart!</span></span>
<span class="line"><span></span></span>
<span class="line"><span>You are 12.</span></span></code></pre>
<p>用jQuery修改name和age节点的内容：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>var name = 'Homer';</span></span>
<span class="line"><span>var age = 51;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$('#name').text(name);</span></span>
<span class="line"><span>$('#age').text(age);</span></span></code></pre>
<p>如果我们使用MVVM框架来实现同样的功能，我们首先并不关心DOM的结构，而是关心数据如何存储。最简单的数据存储方式是使用JavaScript对象：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>var person = {</span></span>
<span class="line"><span>    name: 'Bart',</span></span>
<span class="line"><span>    age: 12</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>我们把变量person看作Model，把HTML某些DOM节点看作View，并假定它们之间被关联起来了。</p>
<p>要把显示的name从Bart改为Homer，把显示的age从12改为51，我们并不操作DOM，而是直接修改JavaScript对象：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>person.name = 'Homer';</span></span>
<span class="line"><span>person.age = 51;</span></span></code></pre>
<p>执行上面的代码，我们惊讶地发现，改变JavaScript对象的状态，会导致DOM结构作出对应的变化！这让我们的关注点从如何操作DOM变成了如何更新JavaScript对象的状态，而操作JavaScript对象比DOM简单多了！</p>
<p>这就是MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！
下图可以很好的解释view viewModel model之间的关系
<img src="https://github.com/woai3c/mini-vue/blob/master/imgs/mvvm.jpg" alt="mvvm"></p>
<h4 id="回到顶部"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vue的优点是什么"><a class="heading-link" aria-label="链接到此标题" href="#vue的优点是什么">Vue的优点是什么</a></h2>
<p>mvvm的优点即是vue的优点，在这里再总结一下：<br>
数据和视频之间的同步工作完全是自动的，无需人为干涉，所以开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，
复杂的数据状态维护完全由 MVVM 来统一管理，节省了很多精力。</p>
<h4 id="回到顶部-1"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-1"></a><a href="#vue">回到顶部</a></h4>
<h2 id="对于生命周期的理解"><a class="heading-link" aria-label="链接到此标题" href="#对于生命周期的理解">对于生命周期的理解</a></h2>
<p>创建一个Vue实例，是一个漫长的过程，要经历初始化，数据合并，模板解析，数据渲染等等一系列过程。
所以，为了能实现在这个过程里面插入自己想要提前做的事情，就有了生命周期钩子函数。</p>
<h4 id="举个例子"><a class="heading-link" aria-label="链接到此标题" href="#举个例子">举个例子：</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>一辆公交车，从出发点A站到终点站B，中间有很多站点，公交车每到一个站点，就得停下来，</span></span>
<span class="line"><span>等待客人上车，然后再驶往下一个站点，一直到终点站为止。</span></span>
<span class="line"><span>A和B之间的站点，就像是这个路程的生命周期。每一个站点都是一个不同的生命周期（站点名不同），</span></span>
<span class="line"><span>只要到了站点，就得执行该站点对应的生命周期函数，</span></span>
<span class="line"><span>只不过每个站点的生命周期函数都是一样的（等待客人上车）。</span></span></code></pre>
<p>Vue中的生命周期也是一样，对应了Vue实例从创建到结束之间的每一个过程。
例如，Vue的<code>beforeCreate</code>周期，指的就是Vue在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>至于Vue具体的生命周期函数有哪些，请看官网<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" class="external-link" rel="noopener noreferrer" target="_blank">API文档</a></p>
<h4 id="回到顶部-2"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-2"></a><a href="#vue">回到顶部</a></h4>
<h2 id="组件传值"><a class="heading-link" aria-label="链接到此标题" href="#组件传值">组件传值</a></h2>
<ul>
<li>父组件通过prop向子组件传值</li>
<li>子组件通过事件向父组件传值</li>
<li>子组件与子组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex</li>
</ul>
<p>具体例子请看<a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" class="external-link" rel="noopener noreferrer" target="_blank">官方文档</a></p>
<h4 id="回到顶部-3"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-3"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vue数据绑定原理"><a class="heading-link" aria-label="链接到此标题" href="#vue数据绑定原理">vue数据绑定原理</a></h2>
<p>Vue的数据双向绑定都是依据Object.defineProperty()这一方法来做的<br>
Object.defineProperty到底有什么作用呢？
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" class="external-link" rel="noopener noreferrer" target="_blank">MDN</a></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Object.defineProperty(obj, prop, descriptor)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>obj</span></span>
<span class="line"><span>要在其上定义属性的对象。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>prop</span></span>
<span class="line"><span>要定义或修改的属性的名称。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>descriptor</span></span>
<span class="line"><span>将被定义或修改的属性描述符。</span></span></code></pre>
<p>简单来说 这个方法可以定义一个对象某个属性的描述符</p>
<p>我们需要用到的就是描述符当中的getter和setter</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>const obj = {a:1}</span></span>
<span class="line"><span>obj.a // 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>obj.a = 2 </span></span></code></pre>
<p>像上面代码中的两个操作 读取和赋值 就是在访问obj.a的getter和setter<br>
当我们输入obj.a时 就是在访问obj对象a属性的getter 当输入obj.a = 2 时就是在访问obj对象a属性的setter</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Object.defineProperty(obj, 'a', {</span></span>
<span class="line"><span>  get : function(){</span></span>
<span class="line"><span>    return val</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  set : function(newValue){</span></span>
<span class="line"><span>    val = newValue</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  enumerable : true,</span></span>
<span class="line"><span>  configurable : true</span></span>
<span class="line"><span>})</span></span></code></pre>
<p>getter和setter都是一个函数 我们还可以这样做 例如</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>get: function() {</span></span>
<span class="line"><span>  // 每次访问obj.a时都会执行这段代码</span></span>
<span class="line"><span>  console.log('hello, 你在读取a的值')</span></span>
<span class="line"><span>  return val</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>set: function(newValue) {</span></span>
<span class="line"><span>  val = newValue</span></span>
<span class="line"><span>  // 每次给obj.a赋值时都会执行这段代码</span></span>
<span class="line"><span>  console.log('你设置了a的值')</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>Vue的双向数据绑定就是根据上面的原理来实现的
只要在读取值时收集观察者 在赋值时触发观察者更新函数 就可以实现数据变更 从而实现DOM重新渲染</p>
<p>说到这可能还不是很明白 不要急 慢慢来 先看一下这段代码 复制放到HTML文件里自己运行一下
然后打开网页 在控制台里输入data.user.name看看 会有惊喜</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>&#x3C;!DOCTYPE html></span></span>
<span class="line"><span>&#x3C;html></span></span>
<span class="line"><span>&#x3C;head></span></span>
<span class="line"><span>    &#x3C;meta charset="utf-8"></span></span>
<span class="line"><span>    &#x3C;title>动态数据绑定（一）&#x3C;/title></span></span>
<span class="line"><span>&#x3C;/head></span></span>
<span class="line"><span>&#x3C;body></span></span>
<span class="line"><span> &#x3C;script></span></span>
<span class="line"><span>    var data = {</span></span>
<span class="line"><span>        user: {</span></span>
<span class="line"><span>            name: 'xiaoming',</span></span>
<span class="line"><span>            age: 18,</span></span>
<span class="line"><span>            occupation: 'frontend'</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        address: {</span></span>
<span class="line"><span>            city: 'shaoguan'</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }; </span></span>
<span class="line"><span>    function Observer(data) {</span></span>
<span class="line"><span>        this.data = data;</span></span>
<span class="line"><span>        this.walk(data);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    Observer.prototype = {</span></span>
<span class="line"><span>        walk: function(obj) {</span></span>
<span class="line"><span>            var value,</span></span>
<span class="line"><span>                key;</span></span>
<span class="line"><span>            for (key in obj) {</span></span>
<span class="line"><span>                if (obj.hasOwnProperty(key)) {</span></span>
<span class="line"><span>                    value = obj[key];</span></span>
<span class="line"><span>                    if (typeof value === 'object') {</span></span>
<span class="line"><span>                        new Observer(value);</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                    this.convert(key, value); </span></span>
<span class="line"><span>                }   </span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        convert: function(key, value) {</span></span>
<span class="line"><span>            Object.defineProperty(this.data, key, {</span></span>
<span class="line"><span>                get : function(){ </span></span>
<span class="line"><span>                    console.log("你访问了" + key);</span></span>
<span class="line"><span>                    return value; </span></span>
<span class="line"><span>                },</span></span>
<span class="line"><span>                set : function(newValue){ </span></span>
<span class="line"><span>                    value = newValue; </span></span>
<span class="line"><span>                    console.log('你设置了' + key + '=' + value);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            });</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>    var example = new Observer(data);</span></span>
<span class="line"><span> &#x3C;/script>   </span></span>
<span class="line"><span>&#x3C;/body></span></span>
<span class="line"><span>&#x3C;/html></span></span></code></pre>
<h4 id="回到顶部-4"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-4"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vue-router原理"><a class="heading-link" aria-label="链接到此标题" href="#vue-router原理">vue-router原理</a></h2>
<p>说简单点，vue-router的原理就是通过对URL地址变化的监听，继而对不同的组件进行渲染。<br>
每当URL地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有hash模式和history模式。<br>
如果想了解得详细点，建议百度或者阅读源码。</p>
<h4 id="回到顶部-5"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-5"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vuex原理"><a class="heading-link" aria-label="链接到此标题" href="#vuex原理">vuex原理</a></h2>
<p>vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？<br>
因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。<br>
store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据，
导致另一个组件上的数据也会改变，就像是一个对象的引用。<br>
如果对vuex的实现有兴趣，可以看看我自己造的一个vue轮子对应的<a href="https://github.com/woai3c/mini-vuex/blob/master/mini-vuex.js" class="external-link" rel="noopener noreferrer" target="_blank">vuex插件</a>。它实现了除vuex模块外的所有功能。</p>
<h4 id="回到顶部-6"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-6"></a><a href="#vue">回到顶部</a></h4>
<h2 id="v-if和v-show的区别"><a class="heading-link" aria-label="链接到此标题" href="#v-if和v-show的区别">v-if和v-show的区别</a></h2>
<p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用<code>v-if</code> 较好。</p>
<p><a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show" class="external-link" rel="noopener noreferrer" target="_blank">https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show</a></p>
<h4 id="回到顶部-7"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-7"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vue怎么实现页面的权限控制"><a class="heading-link" aria-label="链接到此标题" href="#vue怎么实现页面的权限控制">vue怎么实现页面的权限控制</a></h2>
<p>利用 <code>vue-router</code> 的 <code>beforeEach</code> 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。</p>
<h4 id="回到顶部-8"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-8"></a><a href="#vue">回到顶部</a></h4>
<h2 id="keep-alive有什么作用"><a class="heading-link" aria-label="链接到此标题" href="#keep-alive有什么作用">keep-alive有什么作用</a></h2>
<p>在 <code>Vue</code> 中，每次切换组件时，都会重新渲染。如果有多个组件切换，又想让它们保持原来的状态，避免重新渲染，这个时候就可以使用 <code>keep-alive</code>。
<code>keep-alive</code> 可以使被包含的组件保留状态，或避免重新渲染。</p>
<h4 id="回到顶部-9"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-9"></a><a href="#vue">回到顶部</a></h4>
<h2 id="计算属性有什么作用"><a class="heading-link" aria-label="链接到此标题" href="#计算属性有什么作用">计算属性有什么作用</a></h2>
<p>先来看一下计算属性的定义：<br>
当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。<br>
计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。</p>
<h4 id="回到顶部-10"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-10"></a><a href="#vue">回到顶部</a></h4>
<h2 id="route和router的区别"><a class="heading-link" aria-label="链接到此标题" href="#route和router的区别">$route和$router的区别</a></h2>
<p><code>$route</code> 是路由信息对象，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code> 等路由信息参数。</p>
<p>而 <code>$router</code> 是路由实例对象，包括了路由的跳转方法，钩子函数等</p>
<h4 id="回到顶部-11"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-11"></a><a href="#vue">回到顶部</a></h4>
<h2 id="watch的作用是什么"><a class="heading-link" aria-label="链接到此标题" href="#watch的作用是什么">watch的作用是什么</a></h2>
<p><code>watch</code> 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。</p>
<p>借助 <code>watch</code> 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。</p>
<h4 id="回到顶部-12"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-12"></a><a href="#vue">回到顶部</a></h4>
<h2 id="vue-loader是什么使用它的用途有哪些"><a class="heading-link" aria-label="链接到此标题" href="#vue-loader是什么使用它的用途有哪些">vue-loader是什么？使用它的用途有哪些？</a></h2>
<p>vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p>
<p>用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。</p>
<h4 id="回到顶部-13"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-13"></a><a href="#vue">回到顶部</a></h4>
<h2 id="假设定义了一个数组a123相应的页面上显示的值为123现设a05页面上的值会变成523吗为什么"><a class="heading-link" aria-label="链接到此标题" href="#假设定义了一个数组a123相应的页面上显示的值为123现设a05页面上的值会变成523吗为什么">假设定义了一个数组a=[1,2,3]，相应的，页面上显示的值为1,2,3，现设a[0]=5，页面上的值会变成5,2,3吗？为什么？</a></h2>
<p>不会</p>
<p>因为 Vue 是使用 <code>Object.defineProperty</code> 来监听数值变化的，而直接修改数组的值的这种操作无法监听。</p>
<p>例如：<code>vm.items[indexOfItem] = newValue</code> 这种操作是无法监听的。</p>
<p>如果需要直接修改数组元素的值，可以使用 <code>Vue.set</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#E1E4E8">Vue.</span><span style="color:#B392F0">set</span><span style="color:#E1E4E8">(vm.items, indexOfItem, newValue)</span></span></code></pre>
<p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" class="external-link" rel="noopener noreferrer" target="_blank">数组更新检测</a></p>
<h4 id="回到顶部-14"><a class="heading-link" aria-label="链接到此标题" href="#回到顶部-14"></a><a href="#vue">回到顶部</a></h4>  <!-- 评论区域 --> <div id="waline" class="waline-container" data-astro-cid-6z674vj5></div> <script type="module" src="/_astro/WalineComment.astro_astro_type_script_index_0_lang.Dq86Uk2i.js"></script>  </div> <nav class="toc-sidebar" data-astro-cid-bvzihdzo> <h4 data-astro-cid-bvzihdzo>目录</h4> <ul data-astro-cid-bvzihdzo> <li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#什么是mvvm" data-astro-cid-bvzihdzo>什么是mvvm</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#viewmodel如何编写" data-astro-cid-bvzihdzo>ViewModel如何编写？</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vue的优点是什么" data-astro-cid-bvzihdzo>Vue的优点是什么</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-1" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#对于生命周期的理解" data-astro-cid-bvzihdzo>对于生命周期的理解</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#举个例子" data-astro-cid-bvzihdzo>举个例子：</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-2" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#组件传值" data-astro-cid-bvzihdzo>组件传值</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-3" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vue数据绑定原理" data-astro-cid-bvzihdzo>vue数据绑定原理</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-4" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vue-router原理" data-astro-cid-bvzihdzo>vue-router原理</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-5" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vuex原理" data-astro-cid-bvzihdzo>vuex原理</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-6" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#v-if和v-show的区别" data-astro-cid-bvzihdzo>v-if和v-show的区别</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-7" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vue怎么实现页面的权限控制" data-astro-cid-bvzihdzo>vue怎么实现页面的权限控制</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-8" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#keep-alive有什么作用" data-astro-cid-bvzihdzo>keep-alive有什么作用</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-9" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#计算属性有什么作用" data-astro-cid-bvzihdzo>计算属性有什么作用</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-10" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#route和router的区别" data-astro-cid-bvzihdzo>$route和$router的区别</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-11" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#watch的作用是什么" data-astro-cid-bvzihdzo>watch的作用是什么</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-12" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#vue-loader是什么使用它的用途有哪些" data-astro-cid-bvzihdzo>vue-loader是什么？使用它的用途有哪些？</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-13" data-astro-cid-bvzihdzo>回到顶部</a> </li><li class="toc-item toc-h2" data-astro-cid-bvzihdzo> <a href="#假设定义了一个数组a123相应的页面上显示的值为123现设a05页面上的值会变成523吗为什么" data-astro-cid-bvzihdzo>假设定义了一个数组a=[1,2,3]，相应的，页面上显示的值为1,2,3，现设a[0]=5，页面上的值会变成5,2,3吗？为什么？</a> </li><li class="toc-item toc-h4" data-astro-cid-bvzihdzo> <a href="#回到顶部-14" data-astro-cid-bvzihdzo>回到顶部</a> </li> </ul> </nav> </div> </article> </main> <footer data-astro-cid-sz7xmlte>
logyxiao's Blog-&copy; 2025 - by Astro.
<div class="social-links" data-astro-cid-sz7xmlte></div> </footer>  <script>
if (typeof window !== 'undefined') {
	window.addEventListener('DOMContentLoaded', () => {
		const main = document.querySelector('.blog-content-main');
		if (!main) return;

		// 代码块复制按钮
		main.querySelectorAll('pre code').forEach(block => {
			const pre = block.parentElement;
			if (!pre) return;
			const btn = document.createElement('button');
			btn.className = 'copy-btn';
			btn.type = 'button';
			btn.innerText = '复制';
			btn.onclick = () => {
				navigator.clipboard.writeText(block.innerText);
				btn.innerText = '已复制!';
				setTimeout(() => { btn.innerText = '复制'; }, 1200);
			};
			pre.style.position = 'relative';
			btn.style.position = 'absolute';
			btn.style.top = '8px';
			btn.style.right = '12px';
			pre.appendChild(btn);
		});
	});
}
</script> </body></html>